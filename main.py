from art import tprint
from solution import *

print('\n')
tprint('Test task', 'nancyj')
print('\n')

tprint('First:', 'cyberlarge')
print('Реализовано ещё две функции определения четности целого числа:\n'
      ' 1) с помощью целочисленного и обычного деления (value // 2 == value / 2)\n'
      ' 2) c помощью операции побитового сравнения (value & 1 == 0)')

print('\n')
print('С помощью бенчмарков можно продемонстрировать, что операция побитового сравнения выигрывает по\n'
      'производительности у другой реализованной функции:')
print('\n')
print(f'Время выполнения функции value & 1 == 0:')
is_even_opt_3(54398 ** 50)
print(f'Время выполнения функции value // 2 == value / 2:')
is_even_opt_2(54398 ** 50)
print(f'Время выполнения функции value % 2 == 0 (данной в задании):')
is_even_opt_1(54398 ** 50)

print('\n')
print(
    'Мы используем побитовое сравнение с 1, что фактически'
    ' равняется \nпроверки последнего бита числа, и если он равен нулю - число четное, в противном случае нечетное.')
print('\n')
print('Использование целочисленного и обычного деления же работает медленнее всего, так как мы запускаем сразу две\n'
      'операции вместо одной.\n')

print('На мой взгляд плюсом использование функции c % является то, что её проще воспринимать в коде\n'
      'минус - в общем случае, не такая быстрая как побитовое сравнение.')
print('Функция с использованием операции & быстрее в основном работает чуть быстрее, но сложнее для понимания,\n'
      'если вам трудно переводить числа в двоичную систему.')
print('У функции же value // 2 == value / 2 плюсов нет.\n')

print('\n')

# Задание 2
tprint('Second:', 'cyberlarge')


def temp_wrapper(cls):
    Q = cls(6)
    Q.add(-2)
    Q.add(-1)
    print('Added -2, -1: ', Q.get())
    for i in range(10):
        Q.add(i)
    print('Added range(10): ', Q.get())
    Q.pop()
    Q.pop()
    print('Popped 2 elements: ', Q.get())
    Q.add(54)
    Q.add(42)
    print('Added 54, 42 elements: ', Q.get())
    print('\n')


print('Реализовано 3 класса реализовывающих циклический буфер FIFO: \n')

print('CircularQueueOpt1 самая простая реализация из представленных – при инициализации создается лист с заданным\n'
      'размером и заполняется типом None. В последствии при добавлении элемента, первый просто удаляется,\n'
      'а в конец добавляется новый элемент.   Плюсом является лаконичность кода, и, пожалуй, всё.  Минусы –\n'
      'отсутствие возможности динамически получать очередь без None элементов. Медленные операции add – O(n) и pop – '
      'O(n). Отсутствие исключения переполненной очереди. \n')
temp_wrapper(CircularQueueOpt1)
print('CircularQueueOpt2 реализация лучше -  при инициализации создается очередь, заполненная None, с заданной\n'
      'вместимостью, инициализируются атрибуты tail и head для корректной работы методов add и pop. Из плюсов можно\n'
      'выделить динамическое получение не до конца заполненной очереди, быстрые операции add – O (1) и pop – O (1).\n')
temp_wrapper(CircularQueueOpt2)
print('CircularQueueOpt3 реализация немного отличающаяся от предыдущей -  при инициализации создается атрибут max,\n'
      'который отвечает за корректную работу метода add. В этой реализации до того, как все элементы будут заполнены\n'
      'используются методы класса CircularQueueOpt3. После того как все элементы будут заполнены объект будет\n'
      'переопределён в объект приватного класса __Complete. После этого методы будут работать иначе. Из плюсов можно\n'
      'выделить динамическое получение не до конца заполненной очереди, быструю операцию после заполнения add – O (\n'
      '1). Из минусов – медленная операция до заполнения add – O(N) и отсутствие операции pop. Отсутствие исключения '
      'пустой или переполненной очереди.\n')

Q = CircularQueueOpt3(5)
for i in range(4):
    Q.add(i)
print('Class before it was full: ', Q.__class__, Q.get())
Q.add(4)
print('Class after: ', Q.__class__, Q.get())
Q.add(5)
print('Added element 5: ', Q.get())
Q.add(6)
Q.add(7)
Q.add(8)
Q.add(9)
print('Added range of 6 - 9: ', Q.get())

# Задание 3
print('\n')
tprint('Third:', 'cyberlarge')

print(
    'Честно говоря, с заданными параметрами лучшей сортировки просто не существует, все хорошие сортировки работают \n'
    'в среднем за 0(n log n). Была реализована функция быстрой сортировки, но с тем же результатом можно запустить \n'
    'встроенные в питон функции сортировки, и получить примерно такой же результат. Я выбрал её просто потому что \n'
    'мне нравится стратегия «разделяй и властвуй», и эта сортировка хорошо описана в «Грокаем Алгоритмы» Бхаргава \n'
    'Адитья, которую было невероятно интересно читать =).\n')

print('Сортировку стоит выбирать исходя из специфики конкретного случая. \n')
lst = [65, 2, 324, 21, 69, 54]
print('Исходный массив: ', lst)
print('Время работы алгоритма в нано секундах:')
quick_sort(lst)

print('Отсортированный массив: ', lst)
